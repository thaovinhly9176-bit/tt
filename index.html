<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D 地球模型 (Three.js)</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #000; 
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        #info {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            color: white;
            pointer-events: none;
            z-index: 10;
            text-shadow: 0 0 5px #000;
            font-size: 14px;
            opacity: 0.8;
        }
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #00ffff;
            font-size: 20px;
            font-family: monospace;
            z-index: 20;
            transition: opacity 0.5s;
        }
    </style>
    <!-- 引入 Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- 引入 OrbitControls -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
</head>
<body>

    <div id="info">
        <h1>互动 3D 地球</h1>
        <p>左键拖动旋转 | 滚轮缩放 | 右键平移</p>
    </div>
    <div id="loading">正在生成星球纹理...</div>

    <script>
        // 场景变量
        let scene, camera, renderer, controls;
        let earthMesh, atmosphereMesh, cloudsMesh, moonMesh, moonGroup;
        let stars;

        // 纹理加载管理器
        const manager = new THREE.LoadingManager();
        manager.onLoad = function () {
            const loadingEl = document.getElementById('loading');
            if (loadingEl) {
                loadingEl.textContent = "资源加载完成";
                setTimeout(() => { loadingEl.style.opacity = 0; }, 500);
            }
        };
        
        const textureLoader = new THREE.TextureLoader(manager);

        // 初始化函数
        function init() {
            // 1. 创建场景
            scene = new THREE.Scene();
            
            // 2. 设置相机
            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 0, 25); // 将相机向后拉

            // 3. 设置渲染器
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.body.appendChild(renderer.domElement);

            // 4. 添加轨道控制器
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.minDistance = 8;
            controls.maxDistance = 50;

            // 5. 添加灯光
            // 环境光（底光）- 调暗一点，让对比度更强
            const ambientLight = new THREE.AmbientLight(0x111111);
            scene.add(ambientLight);

            // 太阳光（方向光）
            const sunLight = new THREE.DirectionalLight(0xffffff, 2.0);
            sunLight.position.set(50, 30, 50);
            scene.add(sunLight);

            // 添加一点点补光
            const spotLight = new THREE.SpotLight(0x334455, 0.5);
            spotLight.position.set(-50, 0, 20);
            scene.add(spotLight);

            // 6. 创建对象
            createStarfield();
            createEarth();
            createMoon();

            // 注意：加载提示现在由 LoadingManager 处理

            // 7. 开始动画循环
            animate();

            // 8. 监听窗口调整
            window.addEventListener('resize', onWindowResize);
        }

        // --- 生成程序化纹理 (作为备用) ---
        // 如果图片加载失败，我们使用这个生成备用纹理
        function createProceduralTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 1024;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');

            // 背景：深海蓝
            const gradient = ctx.createLinearGradient(0, 0, 0, 512);
            gradient.addColorStop(0, "#001e4d");
            gradient.addColorStop(1, "#004080");
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 1024, 512);

            // 绘制“陆地” (随机绿色斑块)
            ctx.fillStyle = "#2e8b57"; // 海洋绿
            for (let i = 0; i < 40; i++) {
                const x = Math.random() * 1024;
                const y = Math.random() * 512;
                const radius = 30 + Math.random() * 80;
                
                ctx.beginPath();
                ctx.ellipse(x, y, radius, radius * 0.6, Math.random() * Math.PI, 0, Math.PI * 2);
                ctx.fill();
            }
            
            return new THREE.CanvasTexture(canvas);
        }

        function createEarth() {
            const earthRadius = 5;
            const geometry = new THREE.SphereGeometry(earthRadius, 64, 64);

            // 使用高清真实地球纹理
            // 注意：这里使用 GitHub Raw 链接
            const earthMap = textureLoader.load('https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/planets/earth_atmos_2048.jpg', 
                undefined, undefined, (err) => {
                    console.warn("地球纹理加载失败，切换回程序化纹理");
                    if(earthMesh) earthMesh.material.map = createProceduralTexture();
                }
            );
            
            const specularMap = textureLoader.load('https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/planets/earth_specular_2048.jpg');
            const normalMap = textureLoader.load('https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/planets/earth_normal_2048.jpg');

            // 1. 地球本体
            const material = new THREE.MeshPhongMaterial({
                map: earthMap,
                specularMap: specularMap,
                normalMap: normalMap,
                specular: new THREE.Color(0x333333),
                shininess: 5
            });
            
            earthMesh = new THREE.Mesh(geometry, material);
            scene.add(earthMesh);

            // 2. 大气层光晕 (使用自定义 Shader 实现 Fresnel 效果)
            const atmosphereGeometry = new THREE.SphereGeometry(earthRadius + 0.15, 64, 64);
            
            // 简单的顶点着色器：计算法线
            const vertexShader = `
                varying vec3 vNormal;
                void main() {
                    vNormal = normalize(normalMatrix * normal);
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `;

            // 片元着色器：根据视角计算光晕强度
            const fragmentShader = `
                varying vec3 vNormal;
                void main() {
                    float intensity = pow(0.65 - dot(vNormal, vec3(0, 0, 1.0)), 4.0);
                    gl_FragColor = vec4(0.3, 0.6, 1.0, 1.0) * intensity;
                }
            `;

            const atmosphereMaterial = new THREE.ShaderMaterial({
                vertexShader: vertexShader,
                fragmentShader: fragmentShader,
                blending: THREE.AdditiveBlending,
                side: THREE.BackSide, // 渲染背面以获得更好的光晕效果
                transparent: true
            });

            atmosphereMesh = new THREE.Mesh(atmosphereGeometry, atmosphereMaterial);
            scene.add(atmosphereMesh);

            // 3. 独立的云层层
            const cloudMap = textureLoader.load('https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/planets/earth_clouds_1024.png');
            
            const cloudGeo = new THREE.SphereGeometry(earthRadius + 0.05, 64, 64);
            const cloudMat = new THREE.MeshPhongMaterial({
                map: cloudMap,
                transparent: true,
                opacity: 0.8,
                side: THREE.DoubleSide,
                blending: THREE.AdditiveBlending,
                depthWrite: false // 防止云层遮挡造成的渲染伪影
            });
            cloudsMesh = new THREE.Mesh(cloudGeo, cloudMat);
            scene.add(cloudsMesh);
        }

        function createMoon() {
            // 月球组 (用来控制公转)
            moonGroup = new THREE.Group();
            scene.add(moonGroup);

            // 月球几何体
            const geometry = new THREE.SphereGeometry(1.36, 32, 32); // 稍微调整比例 (地球半径5, 月球约1.36)
            
            const moonMap = textureLoader.load('https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/planets/moon_1024.jpg');
            
            const material = new THREE.MeshPhongMaterial({
                map: moonMap,
                shininess: 0
            });
            
            moonMesh = new THREE.Mesh(geometry, material);
            moonMesh.position.set(15, 0, 0); // 调整距离
            
            moonGroup.add(moonMesh);
        }

        function createStarfield() {
            const geometry = new THREE.BufferGeometry();
            const count = 2000;
            const positions = new Float32Array(count * 3);

            for(let i = 0; i < count * 3; i++) {
                // 在 -400 到 400 的范围内随机分布
                positions[i] = (Math.random() - 0.5) * 800; 
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

            const material = new THREE.PointsMaterial({
                size: 0.8,
                color: 0xffffff,
                transparent: true,
                opacity: 0.8,
                sizeAttenuation: true
            });

            stars = new THREE.Points(geometry, material);
            scene.add(stars);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);

            // 地球自转
            if (earthMesh) earthMesh.rotation.y += 0.001;
            if (cloudsMesh) cloudsMesh.rotation.y += 0.0014; // 云层转得比地球稍快
            
            // 月球公转
            if (moonGroup) {
                moonGroup.rotation.y += 0.005; 
                moonMesh.rotation.y += 0.01; // 月球自转
            }

            // 星空缓慢移动
            if (stars) stars.rotation.y -= 0.0002;

            controls.update();
            renderer.render(scene, camera);
        }

        // 启动程序
        window.onload = init;

    </script>
</body>
</html>